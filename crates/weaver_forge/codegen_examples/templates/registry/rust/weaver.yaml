type_mapping:
  int: i64
  double: f64
  boolean: bool
  string: String
  string[]: Vec<String>
  template[string]: String          # Not yet properly handled in codegen
  template[string[]]: Vec<String>   # Not yet properly handled in codegen

templates:
  - pattern: README.md
    filter: .
    application_mode: single
  - pattern: lib.rs.j2
    # The following JQ filter extracts the id, type, brief, and prefix of groups matching the following criteria:
    # - groups with an id starting with the prefix `registry.`
    # - groups of the type `attribute_group`.
    # - groups with a well-defined prefix.
    # - groups with a non-empty list of attributes that are neither deprecated nor experimental.
    # - groups are deduplicated by prefix.
    # - groups are sorted by prefix.
    filter: >
      .groups
      | map(select(.id | startswith("registry.")))
      | map(select(.type == "attribute_group" and .prefix != null and .prefix != "")    
        | { 
          id, 
          type, 
          brief, 
          prefix})
      | unique_by(.prefix)
      | sort_by(.prefix)
    application_mode: single
  - pattern: semantic_attributes.rs.j2
    # The following JQ filter extracts the id, type, brief, prefix, and attributes of groups matching the following
    # criteria:
    # - groups with an id starting with the prefix `registry.`
    # - groups of the type `attribute_group`.
    # - groups with a well-defined prefix.
    # - groups with a non-empty list of attributes that are neither deprecated nor experimental.
    # - groups are sorted by prefix.
    filter: >
      .groups 
      | map(select(.id | startswith("registry."))) 
      | map(select(.type == "attribute_group" and .prefix != null and .prefix != "") 
        | { 
          id, 
          type, 
          brief, 
          prefix, 
          attributes}) 
      | sort_by(.prefix // empty) 
    application_mode: each

# Other examples of filters

# The following JQ filter extracts the id, type, brief, and prefix of groups matching the following criteria:
# - groups with an id starting with the prefix `registry.`
# - groups of the type `attribute_group`.
# - groups with a well-defined prefix.
# - groups with a non-empty list of attributes that are neither deprecated nor experimental.
# - groups are deduplicated by prefix.
# - groups are sorted by prefix.
#    filter: >
#      .groups
#      | map(select(.id | startswith("registry.")))
#      | map(select(.type == "attribute_group" and .prefix != null and .prefix != "")
#        | {
#          id,
#          type,
#          brief,
#          prefix,
#          attributes: (.attributes
#            | map(select(.stability == "experimental" and .deprecated | not)))})
#      | map(select(.attributes | length > 0))
#      | map(
#          {
#            id,
#            type,
#            brief,
#            prefix
#          }
#        )
#      | unique_by(.prefix)
#      | sort_by(.prefix)


# The following JQ filter extracts the id, type, brief, prefix, and attributes of groups matching the following
# criteria:
# - groups with an id starting with the prefix `registry.`
# - groups of the type `attribute_group`.
# - groups with a well-defined prefix.
# - groups with a non-empty list of attributes that are neither deprecated nor experimental.
# - groups are sorted by prefix.
#    filter: >
#      .groups
#      | map(select(.id | startswith("registry.")))
#      | map(select(.type == "attribute_group" and .prefix != null and .prefix != "")
#        | {
#          id,
#          type,
#          brief,
#          prefix,
#          attributes: (.attributes | map(select(.stability == "experimental" and .deprecated | not)))})
#      | sort_by(.prefix // empty)