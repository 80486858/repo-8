// SPDX-License-Identifier: Apache-2.0

//! Generate code for the Semantic Conventions Rust API based on
//! the templates in `templates/registry/rust` and the mini
//! semantic conventions registry in `semconv_registry`.

use std::path::{Path, PathBuf};
use std::process::exit;
use weaver_cache::Cache;
use weaver_common::{in_memory, Logger};
use weaver_common::in_memory::LogMessage;
use weaver_forge::{GeneratorConfig, TemplateEngine};
use weaver_forge::registry::TemplateRegistry;
use weaver_resolver::SchemaResolver;
use weaver_semconv::path::RegistryPath;
use weaver_semconv::registry::SemConvRegistry;

fn main() {
    println!("cargo:rerun-if-changed=templates/registry/rust");
    println!("cargo:rerun-if-changed=semconv_registry");
    println!("cargo:rerun-if-changed=build.rs");

    let target_dir = std::env::var("OUT_DIR").unwrap();

    let logger = in_memory::Logger::new(0);
    let cache = Cache::try_new().unwrap_or_else(|e| {
        process_error(&logger, e)
    });
    let registry_path = RegistryPath::Local {
        path_pattern: "./semconv_registry/".into(),
    };

    let semconv_specs = SchemaResolver::load_semconv_specs(&registry_path, &cache).unwrap_or_else(|e| {
        process_error(&logger, e)
    });

    let registry_id = "test";
    let mut registry = SemConvRegistry::from_semconv_specs(registry_id, semconv_specs);
    let schema = SchemaResolver::resolve_semantic_convention_registry(&mut registry)
        .unwrap_or_else(|e| {
            process_error(&logger, e)
        });
    let config = GeneratorConfig::new("./templates/".into());

    let engine = TemplateEngine::try_new("registry/rust", config)
        .unwrap_or_else(|e| {
            process_error(&logger, e)
        });

    let template_registry = TemplateRegistry::try_from_resolved_registry(
        schema
            .registry(registry_id)
            .expect("Failed to get the registry from the resolved schema"),
        schema.catalog(),
    )
        .unwrap_or_else(|e| {
            process_error(&logger, e)
        });

    let output: PathBuf = target_dir.into();
    engine
        .generate(logger.clone(), &template_registry, output.as_path())
        .unwrap_or_else(|e| {
            process_error(&logger, e)
        });

    print_logs(&logger);

    alter_generated_files(output.as_path());
}

/// Alter all the generated files to replace //! comments with standard // comments
fn alter_generated_files(path: &Path) {
    let walker = walkdir::WalkDir::new(path);
    for entry in walker {
        let entry = entry.unwrap();
        let path = entry.path();
        if path.is_file() {
            let file_content = std::fs::read_to_string(path).unwrap();
            if file_content.contains("DO NOT EDIT, THIS FILE HAS BEEN GENERATED BY WEAVER") {
                println!("cargo:warning=Altering `{}`", path.display());
                let new_file = file_content.replace("//!", "//");
                // remove line starting with pub mod
                let new_file = new_file.lines().filter(|line| !line.starts_with("pub mod")).collect::<Vec<_>>().join("\n");
                std::fs::write(path, new_file).unwrap();
            } else {
                println!("cargo:warning=Skipping `{}`", path.display());
            }
        }
    }
}

fn print_logs(logger: &in_memory::Logger) {
    for log_message in logger.messages() {
        match &log_message {
            LogMessage::Warn(msg) => println!("cargo:warning={}", msg),
            LogMessage::Error(err) => println!("cargo:warning=Error: {}", err),
            _ => { /* Ignore */ }
        }
    }
}

fn process_error(logger: &in_memory::Logger, error: impl std::fmt::Display) -> ! {
    logger.error(&error.to_string());
    print_logs(logger);
    #[allow(clippy::exit)] // Expected behavior
    exit(1)
}