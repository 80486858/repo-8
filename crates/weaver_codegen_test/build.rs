// SPDX-License-Identifier: Apache-2.0

//! Generate code for the Semantic Conventions Rust API based on
//! the templates in `templates/registry/rust` and the mini
//! semantic conventions registry in `semconv_registry`.

use std::collections::HashMap;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::exit;
use weaver_cache::Cache;
use weaver_common::{in_memory, Logger};
use weaver_common::in_memory::LogMessage;
use weaver_forge::{GeneratorConfig, TemplateEngine};
use weaver_forge::registry::TemplateRegistry;
use weaver_resolver::SchemaResolver;
use weaver_semconv::path::RegistryPath;
use weaver_semconv::registry::SemConvRegistry;

fn main() {
    println!("cargo:rerun-if-changed=templates/registry/rust");
    println!("cargo:rerun-if-changed=semconv_registry");
    println!("cargo:rerun-if-changed=build.rs");

    let target_dir = std::env::var("OUT_DIR").unwrap();

    let logger = in_memory::Logger::new(0);
    let cache = Cache::try_new().unwrap_or_else(|e| {
        process_error(&logger, e)
    });
    let registry_path = RegistryPath::Local {
        path_pattern: "./semconv_registry/".into(),
    };

    let semconv_specs = SchemaResolver::load_semconv_specs(&registry_path, &cache).unwrap_or_else(|e| {
        process_error(&logger, e)
    });

    let registry_id = "test";
    let mut registry = SemConvRegistry::from_semconv_specs(registry_id, semconv_specs);
    let schema = SchemaResolver::resolve_semantic_convention_registry(&mut registry)
        .unwrap_or_else(|e| {
            process_error(&logger, e)
        });
    let config = GeneratorConfig::new("./templates/".into());

    let engine = TemplateEngine::try_new("registry/rust", config)
        .unwrap_or_else(|e| {
            process_error(&logger, e)
        });

    let template_registry = TemplateRegistry::try_from_resolved_registry(
        schema
            .registry(registry_id)
            .expect("Failed to get the registry from the resolved schema"),
        schema.catalog(),
    )
        .unwrap_or_else(|e| {
            process_error(&logger, e)
        });

    let output: PathBuf = target_dir.into();
    engine
        .generate(logger.clone(), &template_registry, output.as_path())
        .unwrap_or_else(|e| {
            process_error(&logger, e)
        });

    print_logs(&logger);

    alter_generated_files(output.as_path());
}

fn alter_generated_files(root: &Path) {
    let walker = walkdir::WalkDir::new(root);
    let mut root_module = Module {
        name: "".to_string(),
        content: "".to_string(),
        sub_modules: HashMap::new(),
    };

    for entry in walker {
        let entry = entry.unwrap();
        let path = entry.path();
        // Only process files with the .rs extension that contain the generated comment
        if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
            let file_content = std::fs::read_to_string(path).unwrap();
            if file_content.contains("DO NOT EDIT, THIS FILE HAS BEEN GENERATED BY WEAVER") {
                let relative_path = path.strip_prefix(root).expect("Failed to strip prefix");
                let file_name = path.file_stem().unwrap().to_str().unwrap();
                let parent_modules = relative_path.parent().map_or(vec![], |parent| {
                    let parent = parent.display().to_string();
                    if parent == "" {
                        return vec![];
                    } else {
                        parent.split('/').map(|s| s.to_string()).collect::<Vec<_>>()
                    }
                });

                // Skip generated.rs
                if file_name == "generated"  {
                    continue;
                }

                // Replace //! with //
                let new_file_content = file_content.replace("//!", "//");
                // Remove line starting with pub mod
                let new_file = new_file_content.lines().filter(|line| !line.starts_with("pub mod")).collect::<Vec<_>>().join("\n");

                add_modules(&mut root_module, parent_modules.clone(), file_name.to_string(), new_file);
            }
        }
    }

    let mut output = std::fs::File::create(root.join("generated.rs")).unwrap();
    output.write_all(root_module.generate().as_bytes()).unwrap();
    // println!("cargo:warning=Generated file: {}", root.join("generated.rs").display());
}

struct Module {
    name: String,
    content: String,
    sub_modules: HashMap<String, Module>,
}

impl Module {
    pub fn generate(&self) -> String {
        let mut content = String::new();

        content.push_str(&self.content);

        for module in self.sub_modules.values() {
            content.push_str(&format!("\npub mod {} {{\n", module.name));
            content.push_str(&module.generate());
            content.push_str("\n}\n");
        }
        content
    }
}

fn add_modules(root_module: &mut Module, parent_modules: Vec<String>, file_name: String, file_content: String) {
    let mut current_module = root_module;
    for module_name in parent_modules.iter() {
        let module = current_module.sub_modules.entry(module_name.clone()).or_insert(Module {
            name: module_name.clone(),
            content: "".to_owned(),
            sub_modules: HashMap::new(),
        });
        current_module = module;
    }

    if file_name == "mod" || file_name == "lib" {
        current_module.content = file_content;
    } else {
        _ = current_module.sub_modules.insert(file_name.clone(), Module {
            name: file_name.clone(),
            content: file_content,
            sub_modules: HashMap::new(),
        });
    }
}

fn print_logs(logger: &in_memory::Logger) {
    for log_message in logger.messages() {
        match &log_message {
            LogMessage::Warn(msg) => println!("cargo:warning={}", msg),
            LogMessage::Error(err) => println!("cargo:warning=Error: {}", err),
            _ => { /* Ignore */ }
        }
    }
}

fn process_error(logger: &in_memory::Logger, error: impl std::fmt::Display) -> ! {
    logger.error(&error.to_string());
    print_logs(logger);
    #[allow(clippy::exit)] // Expected behavior
    exit(1)
}